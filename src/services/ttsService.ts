import mime from "mime";
import path from "node:path";
import { writeFile } from "node:fs/promises";

import {
  GEMINI_TTS_REQUESTS_PER_MINUTE,
  GEMINI_TTS_TOKENS_PER_MINUTE,
  aiClient,
  DEFAULT_VOICE,
  MODEL_ID,
  OUTPUT_DIR,
} from "../config.ts";
import { createAudioFileName, ensureDirectory } from "../utils/fs.ts";
import type { AudioChunk } from "../utils/audio.ts";
import { combineAudioChunks, convertBase64ToWav } from "../utils/audio.ts";
import { countTokens } from "../utils/text.ts";

interface InlineDataPart {
  inlineData?: {
    data?: string;
    mimeType?: string;
  };
}

export interface PersistedAudio {
  fileName: string;
  filePath: string;
  mimeType: string;
}

export interface SynthesizeAudioOptions {
  jobId?: string;
}

const REQUEST_WINDOW_MS = 60_000;
const MIN_WAIT_MS = 100;

export async function synthesizeAudioFromSsmlChunks(
  ssmlChunks: string[],
  customVoice?: string,
  requestedFileName?: string,
  options?: SynthesizeAudioOptions
): Promise<PersistedAudio> {
  await ensureDirectory(OUTPUT_DIR);

  if (!ssmlChunks.length) {
    throw new Error("No SSML chunks were provided for synthesis.");
  }

  const voice = customVoice ?? DEFAULT_VOICE;
  const jobLabel = createJobLabel(options?.jobId, "TTS");
  console.log(
    `${jobLabel}Starting audio synthesis with ${ssmlChunks.length} SSML chunk(s) using voice "${voice}".`
  );

  const audioChunks: AudioChunk[] = [];

  for (const [index, chunk] of ssmlChunks.entries()) {
    const chunkNumber = index + 1;
    const tokensNeeded = Math.max(1, countTokens(chunk));
    console.log(
      `${jobLabel}Queueing chunk ${chunkNumber}/${ssmlChunks.length} (~${tokensNeeded} tokens).`
    );

    await ttsRateLimiter.waitForTurn(
      tokensNeeded,
      jobLabel,
      chunkNumber,
      ssmlChunks.length
    );

    try {
      const chunkAudio = await generateAudioFromSsml(
        chunk,
        voice,
        jobLabel,
        chunkNumber,
        ssmlChunks.length
      );
      audioChunks.push(chunkAudio);
      console.log(
        `${jobLabel}Chunk ${chunkNumber}/${ssmlChunks.length} buffered (${chunkAudio.mimeType}).`
      );
    } catch (error) {
      console.error(
        `${jobLabel}Chunk ${chunkNumber}/${ssmlChunks.length} failed. Halting further synthesis.`,
        error
      );
      break;
    }
  }

  if (!audioChunks.length) {
    throw new Error("No audio chunks were generated by Gemini.");
  }

  if (audioChunks.length < ssmlChunks.length) {
    console.warn(
      `${jobLabel}Audio synthesis completed partially (${audioChunks.length}/${ssmlChunks.length}).`
    );
  }

  const combinedAudio = combineAudioChunks(audioChunks);
  const extension = mime.getExtension(combinedAudio.mimeType) ?? "wav";
  const fileName = createAudioFileName(extension, requestedFileName);
  const filePath = path.join(OUTPUT_DIR, fileName);

  await writeFile(filePath, combinedAudio.buffer);
  console.log(`${jobLabel}Audio file saved to ${filePath}`);

  return { fileName, filePath, mimeType: combinedAudio.mimeType };
}

async function generateAudioFromSsml(
  ssml: string,
  voiceName: string,
  jobLabel: string,
  chunkNumber: number,
  totalChunks: number
): Promise<AudioChunk> {
  console.log(
    `${jobLabel}Requesting Gemini audio for chunk ${chunkNumber}/${totalChunks}.`
  );

  const contents = [
    {
      role: "user" as const,
      parts: [{ text: ssml }],
    },
  ];

  const response = await aiClient.models.generateContentStream({
    model: MODEL_ID,
    config: {
      temperature: 0.7,
      responseModalities: ["AUDIO"],
      speechConfig: {
        voiceConfig: {
          prebuiltVoiceConfig: {
            voiceName,
          },
        },
      },
    },
    contents,
  });

  const base64Chunks: string[] = [];
  let mimeType: string | undefined;

  for await (const chunk of response) {
    const candidate = chunk.candidates?.[0];
    const parts = candidate?.content?.parts ?? [];

    for (const part of parts) {
      const inlineData = (part as InlineDataPart).inlineData;
      if (!inlineData) {
        continue;
      }

      if (inlineData.data) {
        base64Chunks.push(inlineData.data);
      }

      if (inlineData.mimeType) {
        mimeType = inlineData.mimeType;
      }
    }
  }

  if (!base64Chunks.length) {
    throw new Error("Gemini did not return audio data.");
  }

  console.log(
    `${jobLabel}Chunk ${chunkNumber}/${totalChunks} audio stream received (${
      mimeType ?? "audio/wav"
    }).`
  );

  const combinedBase64 = base64Chunks.join("");
  if (!mimeType || !mime.getExtension(mimeType)) {
    return {
      buffer: convertBase64ToWav(combinedBase64, mimeType),
      mimeType: "audio/wav",
    };
  }

  return {
    buffer: Buffer.from(combinedBase64, "base64"),
    mimeType,
  };
}

class TtsRateLimiter {
  private requestTimestamps: number[] = [];
  private tokenHistory: Array<{ timestamp: number; tokens: number }> = [];

  async waitForTurn(
    tokensNeeded: number,
    jobLabel: string,
    chunkNumber: number,
    totalChunks: number
  ): Promise<void> {
    while (true) {
      const now = Date.now();
      this.requestTimestamps = this.requestTimestamps.filter(
        (timestamp) => now - timestamp < REQUEST_WINDOW_MS
      );
      this.tokenHistory = this.tokenHistory.filter(
        ({ timestamp }) => now - timestamp < REQUEST_WINDOW_MS
      );

      const requestsUsed = this.requestTimestamps.length;
      const tokensUsed = this.tokenHistory.reduce(
        (sum, { tokens }) => sum + tokens,
        0
      );

      const requestLimitOk =
        requestsUsed < GEMINI_TTS_REQUESTS_PER_MINUTE ||
        GEMINI_TTS_REQUESTS_PER_MINUTE === 0;
      const tokenLimitOk =
        tokensUsed + tokensNeeded <= GEMINI_TTS_TOKENS_PER_MINUTE ||
        GEMINI_TTS_TOKENS_PER_MINUTE === 0;

      if (requestLimitOk && tokenLimitOk) {
        break;
      }

      const oldestRequestTimestamp = this.requestTimestamps[0];
      const nextRequestDelay =
        requestLimitOk || oldestRequestTimestamp === undefined
          ? 0
          : REQUEST_WINDOW_MS - (now - oldestRequestTimestamp);
      const oldestTokenTimestamp = this.tokenHistory[0]?.timestamp;
      const nextTokenDelay =
        tokenLimitOk || !oldestTokenTimestamp
          ? 0
          : REQUEST_WINDOW_MS - (now - oldestTokenTimestamp);

      const waitMs = Math.max(nextRequestDelay, nextTokenDelay, MIN_WAIT_MS);
      console.log(
        `${jobLabel}Rate limit guard active before chunk ${chunkNumber}/${totalChunks}. Waiting ${waitMs}ms.`
      );
      await delay(waitMs);
    }

    const timestamp = Date.now();
    this.requestTimestamps.push(timestamp);
    this.tokenHistory.push({ timestamp, tokens: tokensNeeded });
  }
}

const ttsRateLimiter = new TtsRateLimiter();

function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function createJobLabel(jobId: string | undefined, fallback: string): string {
  if (jobId) {
    return `[Job ${jobId}][${fallback}] `;
  }

  return `[${fallback}] `;
}
